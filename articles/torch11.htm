<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Framework Torch: konfigurace konvolučních neuronových sítí</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Framework Torch: konfigurace konvolučních neuronových sítí</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes si ukážeme, jak dobře či naopak špatně se nám podaří natrénovat konvoluční neuronovou síť takovým způsobem, aby dobře rozpoznávala číslice v zašuměných či jinak upravených rastrových obrázcích.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Framework Torch: konfigurace konvolučních neuronových sítí</a></p>
<p><a href="#k02">2. Ucelený projekt pro trénink a validaci konvoluční neuronové sítě</a></p>
<p><a href="#k03">3. Moduly umístěné v&nbsp;adresáři <strong>image_lib</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k031">3.1 Modul <strong>image_renderer</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k032">3.2 Modul <strong>image_filters</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k033">3.3 Modul <strong>image_generator</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k034">3.4 Modul <strong>image_writer</strong></a></p>
<p><a href="#k04">4. Moduly umístěné v&nbsp;adresáři <strong>nn</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k041">4.1 Modul <strong>nn_constructor</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k042">4.2 Modul <strong>nn_trainer</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k043">4.3 Modul <strong>nn_validators</strong></a></p>
<p><a href="#k05">5. Hlavní modul projektu</a></p>
<p><a href="#k06">6. Průběh učení sítě</a></p>
<p><a href="#k07">7. Vliv šumu vneseného do obrázků na odhad sítě</a></p>
<p><a href="#k08">8. Postupné zvyšování šumu a odhad sítě vynesený do grafů</a></p>
<p><a href="#k09">9. Snížení počtu iterací při tréninku sítě</a></p>
<p><a href="#k10">10. Síť naučená s&nbsp;malým počtem iterací a grafy odhadu sítě pro postupné zvyšování šumu</a></p>
<p><a href="#k11">11. Vliv roztřesení obrázků na odhad sítě</a></p>
<p><a href="#k12">12. Postupné zvyšování míry rozstřesení a odhad sítě vynesený do grafů</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Framework Torch: konfigurace konvolučních neuronových sítí</h2>

<p><a
href="https://www.root.cz/clanky/framework-torch-vyuziti-konvolucnich-siti-pro-rozpoznavani-a-klasifikaci-obrazku/">V&nbsp;předchozím článku</a> <a
href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">seriálu
o frameworku Torch</a> jsme si ukázali způsob konstrukce i natrénování
konvoluční neuronové sítě, která relativně bez problémů dokázala rozpoznat
obrázky číslic, které byly zašuměné (s&nbsp;volitelnou mírou šumu). Dnešní
článek bude tématicky rozdělen na dvě části. V&nbsp;první části nejdříve
vytvoříme z&nbsp;příkladu ukázaného minule projekt rozdělený na několik modulů,
protože s&nbsp;takto navrženým projektem se nám bude mnohem lépe pracovat.
Následně zjistíme závislost přesnosti odhadu neuronové sítě na míře šumu ve
validačních obrázcích, na počtu iterací provedených při tréninku sítě a nakonec
si ukážeme, jak dobře (či v&nbsp;některým případech spíše špatně) dokáže
neuronová síť klasifikovat číslice v&nbsp;obrázcích, které byly
&bdquo;rozstřeseny&ldquo; algoritmem jitteringu. Všechny úpravy budou prováděny
na jediném místě, konkrétně v&nbsp;hlavním skriptu celého projektu (viz
navazující kapitoly).</p>

<p>Tentýž projekt použije i v&nbsp;dalších částech seriálu, pouze v&nbsp;něm
nepatrně upravíme parametry konvoluční sítě (velikost konvolučního jádra
atd.)</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ucelený projekt pro trénink a validaci konvoluční neuronové sítě</h2>

<p>Celý projekt s&nbsp;konvoluční sítí je rozdělen do tří částí:</p>

<ol>

<li>Moduly s&nbsp;konstruktorem neuronové sítě, funkcemi pro její trénink a
taktéž funkcemi pro validaci natrénované sítě. Tyto moduly jsou uloženy
v&nbsp;podadresáři <strong>nn</strong>.</li>

<li>Moduly pro vygenerování trénovacích i validačních obrázků, aplikaci šumu,
roztřesení, posunutí a v&nbsp;neposlední řadě i uložení obrázků do externích
souborů a konverzi obrázků do tenzoru. Tyto moduly jsou uloženy
v&nbsp;podadresáři <strong>image_lib</strong>.</li>

<li>Hlavní modul celého projektu, který obsahuje konstanty použité jak pro
konstrukci sítě, tak i pro vytváření obrázků, trénink sítě atd.</li>

</ol>

<p>Způsob rozdělení projektu do jednotlivých adresářů a souborů je
následující:</p>

<pre>
├── convolution_network_noisy_images.lua
├── image_lib
│   ├── image_filters.lua
│   ├── image_generator.lua
│   ├── image_renderer.lua
│   └── image_writer.lua
└── nn
    ├── nn_constructor.lua
    ├── nn_trainer.lua
    └── nn_validators.lua
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Moduly umístěné v&nbsp;adresáři <strong>image_lib</strong></h2>

<p>V&nbsp;této kapitole je stručně popsána čtveřice modulů umístěných do
adresáře <strong>image_lib</strong>.</p>



<p><a name="k031"></a></p>
<h2 id="k031">3.1 Modul <strong>image_renderer</strong></h2>

<p>Modul <strong>image_renderer</strong> obsahuje funkci nazvanou
<strong>generate_image</strong>, kterou již dobře známe. Připomeňme si, že tato
funkce slouží pro vytvoření dvourozměrné tabulky představující monochromatický
rastrový obrázek číslice 0 až 9. Originální rozlišení generovaných obrázků je
8&times;8 pixelů, ovšem obrázky lze v&nbsp;případě potřeby zvětšit využitím
celočíselného parametru <strong>scale</strong>, takže je možné vytvořit obrázky
o rozlišení 16&times;16 pixelů, 24&times;24 pixelů atd. atd. Dále je možné
specifikovat úroveň tmavých a světlých pixelů, protože se nemusí jednat o zcela
černou či naopak plně bílou barvu (naopak to může neuronovou síť dobře
zmást):</p>

<pre>
digits = {
    {0x00, 0x3C, 0x66, 0x76, 0x6E, 0x66, 0x3C, 0x00 },
    {0x00, 0x18, 0x1C, 0x18, 0x18, 0x18, 0x7E, 0x00 },
    {0x00, 0x3C, 0x66, 0x30, 0x18, 0x0C, 0x7E, 0x00 },
    {0x00, 0x7E, 0x30, 0x18, 0x30, 0x66, 0x3C, 0x00 },
    {0x00, 0x30, 0x38, 0x3C, 0x36, 0x7E, 0x30, 0x00 },
    {0x00, 0x7E, 0x06, 0x3E, 0x60, 0x66, 0x3C, 0x00 },
    {0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x3C, 0x00 },
    {0x00, 0x7E, 0x60, 0x30, 0x18, 0x0C, 0x0C, 0x00 },
    {0x00, 0x3C, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00 },
    {0x00, 0x3C, 0x66, 0x7C, 0x60, 0x30, 0x1C, 0x00 },
}
&nbsp;
&nbsp;
function <strong>get_codes_for_digit</strong>(digit)
    if digit &lt; 0 or digit &gt; 9 then
        return nil
    end
    return digits[digit+1]
end
&nbsp;
&nbsp;
function <strong>setpixel</strong>(image, x, y, bit, white_level, black_level)
    if bit==1 then
        image[y][x] = white_level
    else
        image[y][x] = black_level
    end
end
&nbsp;
&nbsp;
function <strong>generate_image</strong>(digit, scale, black_level, white_level)
    local codes = get_codes_for_digit(digit)
    local image = {}
    local y_offset = 1
    for _, code in ipairs(codes) do
        for y = 1,scale do
            <i>-- vytvorit dalsi obrazovy radek</i>
            image[y_offset] = {}
            local x_offset = 1
            local byte = code
            <i>-- vypocet barev jednotlivych pixelu v obrazku</i>
            for _ = 1,8 do
                <i>-- zjistit hodnotu n-teho bitu + posun bajtu s maskou znaku</i>
                local bit = byte % 2
                byte = (byte - bit)/2
                for x = 1,scale do
                    <i>-- obarveni konkretniho pixelu</i>
                    setpixel(image, x_offset, y_offset, bit, white_level, black_level)
                    x_offset = x_offset + 1
                end
            end
            y_offset = y_offset + 1
        end
    end
    return image
end
</pre>



<p><a name="k031"></a></p>
<h2 id="k032">3.2 Modul <strong>image_filters</strong></h2>

<p>Další modul se jmenuje <strong>image_filters</strong> a jak již jeho název
napovídá, obsahuje tento modul funkce sloužící pro aplikaci různých filtrů na
již existující obrázek (tedy na dvourozměrnou tabulku). Nalezneme zde funkci
pro posun obrázku v&nbsp;horizontálním a/nebo vertikálním směru, pro zašumění
obrázku Gaussovým šumem i funkci pro roztřesení pixelů (jitter). Zejména tato
poslední funkce je zajímavá, protože konvoluční neuronová síť bude mít
s&nbsp;rozpoznáním a klasifikací těchto obrázků velké problémy (ostatně při
větší míře roztřesení bude mít problémy i člověk :-):</p>

<pre>
function <strong>gaussian</strong>(mean, variance)
    return math.sqrt(-2 * variance * math.log(math.random())) *
           math.cos(2 * variance * math.pi * math.random()) + mean
end
&nbsp;
&nbsp;
function <strong>bound</strong>(value, min_value, max_value)
    return math.max(min_value, math.min(value, max_value))
end
&nbsp;
&nbsp;
function <strong>apply_noise</strong>(source_image, variance)
    local target_image = {}
    for y, row in ipairs(source_image) do
        target_image[y] = {}
        for x, pixel in ipairs(row) do
            local delta = math.floor(gaussian(0, variance))
            target_image[y][x] = bound(pixel + delta, 0, 255)
        end
    end
    return target_image
end
&nbsp;
&nbsp;
function <strong>apply_jitter</strong>(source_image, variance)
    local target_image = {}
    local max_x = #source_image[1]
    local max_y = #source_image
&nbsp;
    for y = 1,max_y do
        target_image[y] = {}
        for x = 1,max_x do
            xs = x + math.floor(gaussian(0, variance))
            ys = y + math.floor(gaussian(0, variance))
            xs = bound(xs, 1, max_x)
            ys = bound(ys, 1, max_y)
            target_image[y][x] = source_image[ys][xs]
        end
    end
    return target_image
end
&nbsp;
&nbsp;
function <strong>translate</strong>(source_image, x_offset, y_offset)
    local target_image = {}
    local max_x = #source_image[1]
    local max_y = #source_image
&nbsp;
    for y = 1,max_y do
        target_image[y] = {}
        for x = 1,max_x do
            xs = x - x_offset
            ys = y - y_offset
            xs = bound(xs, 1, max_x)
            ys = bound(ys, 1, max_y)
            target_image[y][x] = source_image[ys][xs]
        end
    end
    return target_image
end
</pre>



<p><a name="k032"></a></p>
<h2 id="k033">3.3 Modul <strong>image_generator</strong></h2>

<p>Modul <strong>image_generator</strong> bude přímo používán jak při tréninku,
tak i při validaci neuronové sítě, protože jsou v&nbsp;něm implementovány
funkce sloužící pro vygenerování trénovacích a validačních obrázků. Tyto
obrázky mají jednoduchou strukturu, protože se jedná o pouhé dvourozměrné
tabulky (tabulka se v&nbsp;jazyku Lua používá jak pro implementaci běžného
pole, tak i pro asociativní pole):</p>

<pre>
function <strong>generate_training_images</strong>(scale, noise_variances, repeat_count, black_level, white_level, export_images)
    local training_images = {}
    for _, noise_variance in ipairs(noise_variances) do
        for digit = 0, 9 do
            for i = 1, repeat_count do
                local training_image = generate_image(digit, scale, black_level, white_level)
                training_image = apply_noise(training_image, noise_variance)
                table.insert(training_images, {digit=digit,
                                               data=training_image})
                if export_images then
                    local filename = string.format("training_%d_%d_%d.pgm", digit, noise_variance, i)
                    write_image(filename, training_image)
                end
            end
        end
    end
    return training_images
end
&nbsp;
&nbsp;
function <strong>noisy_image_filename</strong>(digit, noise_variance)
    return string.format("validation_%d_noise_%d.pgm", digit, noise_variance)
end
&nbsp;
&nbsp;
function <strong>generate_noisy_image_for_validation</strong>(digit, scale, noise_variance, black_level, white_level, export_image)
    local validation_image = generate_image(digit, scale, black_level, white_level)
    validation_image = apply_noise(validation_image, noise_variance)
    if export_image then
        local filename = noisy_image_filename(digit, noise_variance)
        write_image(filename, validation_image)
    end
    return validation_image
end
&nbsp;
&nbsp;
function <strong>jitter_image_filename</strong>(digit, jitter_variance)
    return string.format("validation_%d_jitter_%d.pgm", digit, jitter_variance)
end
&nbsp;
&nbsp;
function <strong>generate_jittered_image_for_validation</strong>(digit, scale, jitter_variance, black_level, white_level, export_image)
    local validation_image = generate_image(digit, scale, black_level, white_level)
    validation_image = apply_jitter(validation_image, jitter_variance)
    if export_image then
        local filename = jitter_image_filename(digit, jitter_variance)
        write_image(filename, validation_image)
    end
    return validation_image
end
</pre>

<p>Pro převod obrázků do trojrozměrného tenzoru se používá funkce
<strong>image2tensor</strong>. A proč vlastně potřebujeme trojrozměrný vektor a
nikoli vektor dvourozměrný? Na vstupu konvolučních neuronových sítí se
používají trojrozměrné tenzory z&nbsp;toho důvodu, že se původní obrázky
s&nbsp;pixely reprezentovanými v&nbsp;barvovém prostoru RGB, YUV, YCbCr atd.
rozdělí do jednotlivých bitových rovin, kde každá rovina obsahuje pouze
zvolenou složku pixelu (například tedy červenou barvovou složku). V&nbsp;našem
případě máme zjednodušenou práci, protože používáme monochromatické obrázky,
takže trojrozměrný tenzor bude mít velikost první dimenze rovnu jedné:</p>

<pre>
function <strong>image2tensor</strong>(image)
    local table3d = {image}
    return torch.Tensor(table3d):double()
end
</pre>



<p><a name="k034"></a></p>
<h2 id="k034">3.4 Modul <strong>image_writer</strong></h2>

<p>Modul pojmenovaný <strong>image_writer</strong> obsahuje jedinou funkci
sloužící pro uložení obrázku do externího souboru ve formátu <i>PGM</i>
(<i>Portable GrayMap</i>), který dokáže knihovna Torch načíst. Ve skutečnosti
však v&nbsp;dnešním projektu použijeme tuto funkci jen pro ladicí účely,
protože generované a ukládané obrázky nebudeme načítat zpět, ale přímo si je
(v&nbsp;operační paměti) převedeme do trojrozměrného tenzoru:</p>

<pre>
function <strong>write_image</strong>(filename, image)
    local fout = io.open(filename, "w")
    if not fout then
        return
    end
&nbsp;
    <i>-- rozliseni obrazku</i>
    local x_resolution = #image[1]
    local y_resolution = #image
&nbsp;
    <i>-- zapis hlavicky</i>
    fout:write("P2\n")
    fout:write(x_resolution)
    fout:write(" ")
    fout:write(y_resolution)
    fout:write("\n255\n")
&nbsp;
    <i>-- zapis jednotlivych pixelu</i>
    for j, row in ipairs(image) do
        for i, pixel in ipairs(row) do
            <i>-- logika pro oddeleni hodnot</i>
            if i ~= 1 then
                fout:write(" ")
            end
            fout:write(pixel)
        end
        <i>-- odradkovani neni nutne</i>
        fout:write("\n")
    end
&nbsp;
    fout:close()
end
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Moduly umístěné v&nbsp;adresáři <strong>nn</strong></h2>

<p>V&nbsp;této kapitole je stručně popsána čtveřice modulů umístěných do
adresáře <strong>nn</strong>.</p>



<p><a name="k041"></a></p>
<h2 id="k041">4.1 Modul <strong>nn_constructor</strong></h2>

<p>Tento modul obsahuje funkci <strong>construct_neural_network</strong>
určenou pro vytvoření konvoluční neuronové sítě se specifikovanou konfigurací
&ndash; rozlišením vstupních obrázků, počtem rovin (atributů), počtem skrytých
neuronů ve druhé polovině sítě atd. S&nbsp;významem jednotlivých konfiguračních
parametrů jsme se seznámili v&nbsp;předchozím článku:</p>

<pre>
function <strong>calculate_size_after_convolution</strong>(input_size, middle_planes, convolution_kernel_size)
    local size = input_size
    for i=1,#middle_planes do
        <i>-- velikost po projiti konvolucni vrstvou</i>
        size = size - convolution_kernel_size + 1
        <i>-- velikost po projiti pooling vrstvou</i>
        size = size / 2
    end
    return size
end
&nbsp;
&nbsp;
function <strong>construct_neural_network</strong>(width, height, input_planes, middle_planes,
                                  hidden_neurons, output_neurons,
                                  convolution_kernel_size, pooling_size, pooling_step)
    local network = nn.Sequential()
&nbsp;
    local size_x = calculate_size_after_convolution(width, middle_planes, convolution_kernel_size)
    local size_y = calculate_size_after_convolution(height, middle_planes, convolution_kernel_size)
&nbsp;
    print("Size x: " .. size_x)
    print("Size y: " .. size_y)
&nbsp;
    <i>-- prvni konvolucni vrstva ocekavajici na vstupu 3D tenzor</i>
    <i>-- o velikosti:</i>
    <i>-- INPUT_PLANES x vyska x sirka</i>
    --
    <i>-- vysledkem je 3D tenzor o velikosti:</i>
    <i>-- MIDDLE_PLANES_1 x (vyska - CONVOLUTION_KERNEL_SIZE + 1) x (sirka - CONVOLUTION_KERNEL_SIZE + 1) </i>
    network:add(nn.SpatialConvolution(input_planes, middle_planes[1], convolution_kernel_size, convolution_kernel_size))
&nbsp;
    <i>-- nyni mame mezivysledky 64 x (vyska-5+1) x (sirka-5+1)</i>
&nbsp;
    <i>-- nelinearni funkce</i>
    network:add(nn.Tanh())
&nbsp;
    <i>-- hledani maxima v regionech o velikosti 2x2 pixely</i>
    <i>-- s krokem nastavenym na 2 pixely v horizontalnim i 2 pixely ve vertikalnim smeru</i>
    network:add(nn.SpatialMaxPooling(pooling_size, pooling_size, pooling_step, pooling_step))
&nbsp;
    <i>-- druha konvolucni vrstva ocekavajici na vstupu 3D tenzor</i>
    <i>-- o velikosti MIDDLE_PLANES_1 x vyska x sirka</i>
    network:add(nn.SpatialConvolution(middle_planes[1], middle_planes[2], convolution_kernel_size, convolution_kernel_size))
&nbsp;
    <i>-- nelinearni funkce</i>
    network:add(nn.Tanh())
&nbsp;
    <i>-- opetovne hledani maxima v regionech o velikosti 2x2 pixely</i>
    <i>-- s krokem nastavenym na 2 pixely v horizontalnim i 2 pixely ve vertikalnim smeru</i>
    network:add(nn.SpatialMaxPooling(pooling_size, pooling_size, pooling_step, pooling_step))
&nbsp;
    <i>-- zmena tvaru: z 3D tenzoru AxBxC na 1D tenzor s A*B*C elementy</i>
    network:add(nn.View(middle_planes[2]*size_x*size_y))
&nbsp;
    <i>-- bezne vrstvy, jak je jiz zname</i>
    network:add(nn.Linear(middle_planes[2]*size_x*size_y, hidden_neurons))
&nbsp;
    <i>-- pridana nelinearni funkce</i>
    network:add(nn.ReLU())
&nbsp;
    <i>-- bezne vrstvy, jak je jiz zname</i>
    network:add(nn.Linear(hidden_neurons, output_neurons))
&nbsp;
    return network
end
</pre>



<p><a name="k041"></a></p>
<h2 id="k042">4.2 Modul <strong>nn_trainer</strong></h2>

<p>V&nbsp;modulu <strong>nn_trainer</strong> nalezneme především funkci volanou
pro vlastní trénink sítě (<strong>train_neural_network</strong>), ale taktéž
funkci <strong>prepare_training_data</strong>, která ze sady vygenerovaných
testovacích obrázků vytvoří tenzor určený pro trénink sítě. Připomeňme si, že
tento tenzor obsahuje dvojice vstup:očekávaný-výstup, přičemž vstupem jsou
jednotlivé obrázky (převedené na tenzory) a výstupem pak tenzor s&nbsp;váhou
odhadu jednotlivých číslic:</p>

<pre>
function <strong>train_neural_network</strong>(network, training_data, learning_rate, max_iteration)
    local criterion = nn.MSECriterion()
    local trainer = nn.StochasticGradient(network, criterion)
    trainer.learningRate = learning_rate
    trainer.maxIteration = max_iteration
    trainer:train(training_data)
end
&nbsp;
&nbsp;
function <strong>generate_expected_output</strong>(digit)
    local result = torch.zeros(DIGITS)
    result[digit+1] = 1
    return result
end
&nbsp;
&nbsp;
function <strong>prepare_training_data</strong>(scale, noise_variances, repeat_count,
                               black_level, white_level, export_images)
    local training_images = generate_training_images(scale, noise_variances, repeat_count,
                                                     black_level, white_level, export_images)
    local training_data_size = #training_images
    local training_data = {}
    function <strong>training_data:size</strong>() return training_data_size end
&nbsp;
    for i, training_image in ipairs(training_images) do
        local input = image2tensor(training_image.data)
        local digit = training_image.digit
        local output = generate_expected_output(digit)
        training_data[i] = {input, output}
    end
&nbsp;
    return training_data
end
</pre>



<p><a name="k043"></a></p>
<h2 id="k043">4.3 Modul <strong>nn_validators</strong></h2>

<p>Tento modul je ze všech popisovaných modulů nejrozsáhlejší, protože obsahuje
několik funkcí, které nejenom validují odhady natrénované neuronové sítě, ale
také vykreslí grafy s&nbsp;váhami (pravděpodobnostmi) jednotlivých odhadů.
Význam jednotlivých funkcí si ukážeme v&nbsp;navazujících kapitolách:</p>

<pre>
function <strong>find_largest_item</strong>(tensor)
    local index = -1
    local value = -math.huge
    for i = 0, 9 do
        if tensor[i+1] &gt; value then
            index = i
            value = tensor[i+1]
        end
    end
    return index, value
end
&nbsp;
&nbsp;
function <strong>plot_graph</strong>(filename, values)
    gnuplot.pngfigure(filename)
    gnuplot.imagesc(values, 'color')
    gnuplot.raw("set terminal pngcairo size 1280, 480")
    gnuplot.plotflush()
    gnuplot.close()
end
&nbsp;
&nbsp;
function <strong>validate_neural_network_using_noise_images</strong>(network, scale, noise, black_level, white_level, export_images)
    local errors = 0
    local count = 0
    for expected_digit = 0, 9 do
        local input = image2tensor(generate_noisy_image_for_validation(expected_digit, scale, noise, black_level, white_level, export_images))
        local output = network:forward(input)
        local result, weight = find_largest_item(output)
        if expected_digit ~= result then
            errors = errors + 1
        end
        print(expected_digit, result, expected_digit==result, weight)
        count = count + 1
    end
    print("---------------------")
    print("Errors: " .. errors)
    print("Error rate: " .. 100.0*errors/count .. "%")
end
&nbsp;
&nbsp;
function <strong>validate_neural_network_variable_noise</strong>(network, scale, digit,
                                                black_level, white_level, export_images)
    local max_noise = 1000
    local values = torch.Tensor(max_noise, DIGITS)
&nbsp;
    for noise_variance = 1, max_noise do
        local input = image2tensor(generate_noisy_image_for_validation(digit, scale, noise_variance,
                                                                       black_level, white_level, export_images))
        local output = network:forward(input)
        values[noise_variance] = output
    end
    local output_graph_filename = string.format("digit%d_variable_noise.png", digit)
    plot_graph(output_graph_filename, values:t())
end
&nbsp;
&nbsp;
function <strong>validate_neural_network_using_jittered_images</strong>(network, scale, jitter_variance, black_level, white_level, export_images)
    local errors = 0
    local count = 0
    for expected_digit = 0, 9 do
        local input = image2tensor(generate_jittered_image_for_validation(expected_digit, scale, jitter_variance,
                                                                          black_level, white_level, export_images))
        local output = network:forward(input)
        local result, weight = find_largest_item(output)
        if expected_digit ~= result then
            errors = errors + 1
        end
        print(expected_digit, result, expected_digit==result, weight)
        count = count + 1
    end
    print("---------------------")
    print("Errors: " .. errors)
    print("Error rate: " .. 100.0*errors/count .. "%")
end
&nbsp;
&nbsp;
function <strong>validate_neural_network_variable_jitter</strong>(network, scale, digit,
                                                 black_level, white_level, export_images)
    local max_jitter = 20
    local values = torch.Tensor(max_jitter, DIGITS)
&nbsp;
    for jitter_variance = 1, max_jitter do
        local input = image2tensor(generate_jittered_image_for_validation(digit, scale, jitter_variance,
                                                                          black_level, white_level, export_images))
        local output = network:forward(input)
        values[jitter_variance] = output
    end
&nbsp;
    local output_graph_filename = string.format("digit%d_variable_jitter.png", digit)
    plot_graph(output_graph_filename, values:t())
end
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Hlavní modul projektu</h2>

<p>Hlavní modul celého projektu je uložen v&nbsp;souboru nazvaném
<strong>convolution_network_noisy_images.lua</strong>. Jedná se o jediný modul,
který budeme postupně modifikovat, protože právě zde jsou uloženy všechny
konfigurační parametry &ndash; rozměry trénovacích i validačních obrázků, počet
iterací při tréninku sítě, architektura navržené konvoluční sítě atd. Na konci
skriptu je umístěn programový kód určený pro validaci; část kódu bude vždycky
zakomentovaná:</p>

<pre>
require("nn")
require("image")
require("gnuplot")
&nbsp;
require("image_lib/image_renderer")
require("image_lib/image_writer")
require("image_lib/image_filters")
require("image_lib/image_generator")
&nbsp;
require("nn/nn_constructor")
require("nn/nn_trainer")
require("nn/nn_validators")
&nbsp;
&nbsp;
<i>-- globalni nastaveni</i>
DIGITS = 10
&nbsp;
&nbsp;
<i>-- parametry obrazku</i>
WIDTH = 32
HEIGHT = 32
BLACK_LEVEL = 64
WHITE_LEVEL = 192
&nbsp;
&nbsp;
<i>-- parametry neuronove site</i>
INPUT_PLANES = 1
&nbsp;
MIDDLE_PLANES = {64, 64}
&nbsp;
HIDDEN_NEURONS = 100
OUTPUT_NEURONS = 10
&nbsp;
<i>-- parametry konvolucni vrstvy</i>
CONVOLUTION_KERNEL_SIZE = 5
&nbsp;
<i>-- parametry pooling vrstvy</i>
POOLING_SIZE = 2
POOLING_STEP = 2
&nbsp;
<i>-- parametry pro uceni neuronove site</i>
MAX_ITERATION = 20
LEARNING_RATE = 0.01
&nbsp;
<i>-- dalsi parametry</i>
EXPORT_IMAGES = true
&nbsp;
&nbsp;
&nbsp;
network = construct_neural_network(WIDTH, HEIGHT, INPUT_PLANES, MIDDLE_PLANES,
                                   HIDDEN_NEURONS, OUTPUT_NEURONS,
                                   CONVOLUTION_KERNEL_SIZE, POOLING_SIZE, POOLING_STEP)
print(network)
&nbsp;
NOISE_VARIANCES = {0, 10, 20, 50}
REPEAT_COUNT = 3
SCALE = 4
&nbsp;
training_data = prepare_training_data(SCALE, NOISE_VARIANCES, REPEAT_COUNT,
                                      BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
&nbsp;
train_neural_network(network, training_data, LEARNING_RATE, MAX_ITERATION)
&nbsp;
validate_neural_network_using_noise_images(network, SCALE, 100, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 1000, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 2500, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 5000, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
&nbsp;
os.exit(1)
&nbsp;
for digit = 0, 9 do
    print("splot for digit " .. digit)
    validate_neural_network_variable_noise(network, SCALE, digit, BLACK_LEVEL, WHITE_LEVEL)
end
&nbsp;
&nbsp;
validate_neural_network_using_jittered_images(network, SCALE, 1, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_jittered_images(network, SCALE, 2, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_jittered_images(network, SCALE, 5, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_jittered_images(network, SCALE, 10, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_jittered_images(network, SCALE, 20, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
&nbsp;
for digit = 0, 9 do
    print("splot for digit " .. digit)
    validate_neural_network_variable_jitter(network, SCALE, digit, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
end
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Průběh učení sítě</h2>

<p>Nejprve zkonstruujeme novou konvoluční neuronovou síť a necháme si
vytisknout její strukturu:</p>

<pre>
network = construct_neural_network(WIDTH, HEIGHT, INPUT_PLANES, MIDDLE_PLANES,
                                   HIDDEN_NEURONS, OUTPUT_NEURONS,
                                   CONVOLUTION_KERNEL_SIZE, POOLING_SIZE, POOLING_STEP)
print(network)
</pre>

<p>Struktura vypadá následovně:</p>

<pre>
nn.Sequential {
  [input -&gt; (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (5) -&gt; (6) -&gt; (7) -&gt; (8) -&gt; (9) -&gt; (10) -&gt; output]
  (1): nn.SpatialConvolution(1 -&gt; 64, 5x5)
  (2): nn.Tanh
  (3): nn.SpatialMaxPooling(2x2, 2,2)
  (4): nn.SpatialConvolution(64 -&gt; 64, 5x5)
  (5): nn.Tanh
  (6): nn.SpatialMaxPooling(2x2, 2,2)
  (7): nn.View(1600)
  (8): nn.Linear(1600 -&gt; 100)
  (9): nn.ReLU
  (10): nn.Linear(100 -&gt; 10)
}
</pre>

<p>Pro učení sítě využijeme sadu trénovacích obrázků, v&nbsp;nichž jsou
jednotlivé číslice částečně zašuměny. Obrázky nám dodá funkce
<strong>generate_training_images</strong> volaná z&nbsp;funkce
<strong>prepare_training_data</strong>. Následně pouze zavoláme funkci pro
tréning sítě:</p>

<pre>
NOISE_VARIANCES = {0, 10, 20, 50}
REPEAT_COUNT = 3
SCALE = 4
&nbsp;
training_data = prepare_training_data(SCALE, NOISE_VARIANCES, REPEAT_COUNT,
                                      BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
&nbsp;
train_neural_network(network, training_data, LEARNING_RATE, MAX_ITERATION)
</pre>

<p>Průběh učení naznačuje, že chyba poměrně rychle klesá, tj.&nbsp;síť se dobře
učí (trénuje):</p>

<pre>
# StochasticGradient: training
# current error = 0.076597900332967
# current error = 0.043665505304942
# current error = 0.024003421497494
# current error = 0.012576232816519
# current error = 0.0064539779976954
# current error = 0.0033509310961456
# current error = 0.0017758012965287
# current error = 0.00095901274943609
# current error = 0.00054799449188649
# current error = 0.00033867089602328
...
...
...
# current error = 9.2518066766304e-06
# current error = 9.1928849962747e-06
# current error = 9.1277176146737e-06
# current error = 9.0550642351311e-06
# current error = 8.9960301984168e-06
# current error = 8.9447400204176e-06
# current error = 8.8771303483088e-06
# StochasticGradient: you have reached the maximum number of iterations
# training error = 8.8771303483088e-06
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vliv šumu vneseného do obrázků na odhad sítě</h2>

<p>Podívejme se nyní na to, jak dobře či naopak špatně bude naše konvoluční
neuronová síť rozpoznávat zašuměné obrázky. Pro relativně malé úrovně šumu by
měl být odhad velmi dobrý, ostatně přesně na takové obrázky byla síť
natrénována. Ovšem s&nbsp;rostoucí mírou šumu se bude odhad zhoršovat, což ale
platí i pro člověka (uvidíte sami při pohledu na obrázky, jak
&bdquo;snadné&ldquo; to někdy je).</p>

<p>Postupně spustíme následující čtveřici funkcí:</p>

<pre>
validate_neural_network_using_noise_images(network, SCALE, 100, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 1000, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 2500, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
validate_neural_network_using_noise_images(network, SCALE, 5000, BLACK_LEVEL, WHITE_LEVEL, EXPORT_IMAGES)
</pre>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 100:</p>

<pre>
0       0       true    0.92901758582303
1       1       true    0.914798882625
2       2       true    0.90179615034807
3       3       true    0.94704201146714
4       4       true    0.95418884655987
5       5       true    0.94832194965547
6       6       true    0.90328739214275
7       7       true    0.90261509534692
8       8       true    0.9278343906419
9       9       true    0.90061346217945
---------------------
Errors: 0
Error rate: 0%
</pre>

<img src="https://i.iinfo.cz/images/396/torch11a-1.png" class="image-315860" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 1: Validační obrázky s&nbsp;úrovní šumu (rozptylem) nastaveným na
hodnotu 100.</i></p>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 1000:</p>

<pre>
0       0       true    0.71679340667254
1       1       true    0.46674692091274
2       2       true    0.68365225813303
3       3       true    0.61487049242692
4       4       true    0.59118905950355
5       5       true    0.66081431702508
6       6       true    0.4819882432665
7       7       true    0.44086099586168
8       8       true    0.51702969306145
9       9       true    0.44992202255959
---------------------
Errors: 0
Error rate: 0%
</pre>

<img src="https://i.iinfo.cz/images/396/torch11a-2.png" class="image-315861" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 2: Validační obrázky s&nbsp;úrovní šumu (rozptylem) nastaveným na
hodnotu 1000.</i></p>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 2500 (zde již došlo
k&nbsp;chybnému odhadu):</p>

<pre>
0       0       true    0.49964226424318
1       2       false   0.31674926934743
2       2       true    0.54998900222653
3       3       true    0.42461270684221
4       4       true    0.42353880107808
5       5       true    0.41895086570902
6       6       true    0.44201805138505
7       7       true    0.35794764982959
8       8       true    0.49182046062964
9       9       true    0.36450208880863
---------------------
Errors: 1
Error rate: 10%
</pre>

<img src="https://i.iinfo.cz/images/396/torch11a-3.png" class="image-315862" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 3: Validační obrázky s&nbsp;úrovní šumu (rozptylem) nastaveným na
hodnotu 2500.</i></p>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 5000 (zde se síť
spletla třikrát, ovšem sami se podívejte na obrázky):</p>

<pre>
0       0       true    0.35376672201379
1       2       false   0.29025898930581
2       2       true    0.60442824010849
3       3       true    0.28843739459533
4       4       true    0.31849058724296
5       5       true    0.29310021725369
6       2       false   0.31115736833006
7       2       false   0.44993918004451
8       8       true    0.44275804344617
9       9       true    0.31744106228322
---------------------
Errors: 3
Error rate: 30%
</pre>

<img src="https://i.iinfo.cz/images/396/torch11a-4.png" class="image-315863" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 4: Validační obrázky s&nbsp;úrovní šumu (rozptylem) nastaveným na
hodnotu 5000.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Postupné zvyšování šumu a odhad sítě vynesený do grafů</h2>

<p>Zajímavé bude sledovat, jak se bude odhad sítě zhoršovat s&nbsp;rostoucím
šumem (což jsme si již ukázali u &bdquo;obyčejné&ldquo; neuronové sítě). Proto
použijeme již výše popsanou funkci nazvanou
<strong>validate_neural_network_variable_noise</strong> z&nbsp;modulu
<strong>nn_validators</strong>, v&nbsp;níž vykreslíme podobné grafy pro
verifikační data, ovšem nyní se bude s&nbsp;každým měřením zvětšovat míra šumu
až na hodnotu 1024.</p>

<p>Výsledkem je pouhých deset grafů pro deset číslic, takže si je uvedeme
všechny. Z&nbsp;grafů je patrné, že si je konvoluční síť v&nbsp;odhadu číslic
velmi jistá, a to i pro vysoké úrovně šumu:</p>

<a href="https://www.root.cz/obrazek/315864/"><img src="https://i.iinfo.cz/images/396/torch11a-5-prev.png" class="image-315864" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 5: Odhad pro číslici 0 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315865/"><img src="https://i.iinfo.cz/images/396/torch11a-6-prev.png" class="image-315865" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 6: Odhad pro číslici 1 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315866/"><img src="https://i.iinfo.cz/images/396/torch11a-7-prev.png" class="image-315866" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 7: Odhad pro číslici 2 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315867/"><img src="https://i.iinfo.cz/images/396/torch11a-8-prev.png" class="image-315867" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 8: Odhad pro číslici 3 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315868/"><img src="https://i.iinfo.cz/images/396/torch11a-9-prev.png" class="image-315868" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 9: Odhad pro číslici 4 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315869/"><img src="https://i.iinfo.cz/images/396/torch11a-10-prev.png" class="image-315869" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 10: Odhad pro číslici 5 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315870/"><img src="https://i.iinfo.cz/images/396/torch11a-11-prev.png" class="image-315870" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 11: Odhad pro číslici 6 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315871/"><img src="https://i.iinfo.cz/images/396/torch11a-12-prev.png" class="image-315871" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 12: Odhad pro číslici 7 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315872/"><img src="https://i.iinfo.cz/images/396/torch11a-13-prev.png" class="image-315872" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 13: Odhad pro číslici 8 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315873/"><img src="https://i.iinfo.cz/images/396/torch11a-14-prev.png" class="image-315873" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 14: Odhad pro číslici 9 pro střední hodnotu šumu od 0 do 1000.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Snížení počtu iterací při tréninku sítě</h2>

<p>Pokud snížíme počet iterací až na hodnotu 10 (což je obecně velmi málo,
typicky se používá hodnota o dva až tři řády vyšší), kupodivu se odhad sítě
razantně nezhorší, alespoň ve chvíli, kdy se snažíme rozpoznat a kvalifikovat
zašuměné obrázky. Ostatně se o tom můžeme relativně snadno přesvědčit:</p>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 100:</p>

<pre>
0       0       true    0.9007039796097
1       1       true    0.84988676812512
2       2       true    0.88670165441306
3       3       true    0.85716831216868
4       4       true    0.96028286120409
5       5       true    0.89073656326969
6       6       true    0.85229764211598
7       7       true    0.84117398125546
8       8       true    0.78770696900435
9       9       true    0.91263127172923
---------------------
Errors: 0
Error rate: 0%
</pre>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 1000:</p>

<pre>
0       0       true    0.56502721095338
1       1       true    0.57947685218729
2       2       true    0.73469718583774
3       3       true    0.59729417113505
4       4       true    0.65922615777093
5       5       true    0.55426296544767
6       6       true    0.56374782525079
7       7       true    0.45865045184205
8       8       true    0.36333484963251
9       9       true    0.72257957894121
---------------------
Errors: 0
Error rate: 0%
</pre>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 2500:</p>

<pre>
0       0       true    0.36889956402128
1       1       true    0.397362275251
2       2       true    0.54447832474612
3       3       true    0.58269293319752
4       4       true    0.49334754817544
5       5       true    0.47956458843779
6       6       true    0.37250860985059
7       7       true    0.3606193371519
8       8       true    0.35734223008066
9       9       true    0.47358258851812
---------------------
Errors: 0
Error rate: 0%
</pre>

<p>Odhady pro úroveň šumu (rozptyl) nastavený na hodnotu 5000:</p>

<pre>
0       2       false   0.27487188812131
1       2       false   0.28982103104273
2       2       true    0.41970028064418
3       3       true    0.4897877895855
4       4       true    0.42139011829457
5       5       true    0.43697124536669
6       5       false   0.2193472198283
7       2       false   0.34779616116913
8       3       false   0.24852067159185
9       9       true    0.33917120557291
---------------------
Errors: 5
Error rate: 50%
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Síť naučená s&nbsp;malým počtem iterací a grafy odhadu sítě pro postupné zvyšování šumu</h2>

<p>Opět si ukažme grafy, v&nbsp;nichž je vynesen odhad sítě (která číslice se
na obrázku nachází) pro postupné zvyšování šumu. Tentokrát byla síť naučena
velmi rychle, ovšem ukazuje se, že stále poměrně kvalitně:</p>

<a href="https://www.root.cz/obrazek/315874/"><img src="https://i.iinfo.cz/images/636/torch11b-1-prev.png" class="image-315874" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 15: Odhad pro číslici 0 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315875/"><img src="https://i.iinfo.cz/images/636/torch11b-2-prev.png" class="image-315875" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 16: Odhad pro číslici 1 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315876/"><img src="https://i.iinfo.cz/images/636/torch11b-3-prev.png" class="image-315876" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 17: Odhad pro číslici 2 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315877/"><img src="https://i.iinfo.cz/images/636/torch11b-4-prev.png" class="image-315877" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 18: Odhad pro číslici 3 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315878/"><img src="https://i.iinfo.cz/images/636/torch11b-5-prev.png" class="image-315878" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 19: Odhad pro číslici 4 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315879/"><img src="https://i.iinfo.cz/images/636/torch11b-6-prev.png" class="image-315879" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 20: Odhad pro číslici 5 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315880/"><img src="https://i.iinfo.cz/images/636/torch11b-7-prev.png" class="image-315880" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 21: Odhad pro číslici 6 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315881/"><img src="https://i.iinfo.cz/images/636/torch11b-8-prev.png" class="image-315881" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 22: Odhad pro číslici 7 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315882/"><img src="https://i.iinfo.cz/images/636/torch11b-9-prev.png" class="image-315882" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 23: Odhad pro číslici 8 pro střední hodnotu šumu od 0 do 1000.</i></p>

<a href="https://www.root.cz/obrazek/315883/"><img src="https://i.iinfo.cz/images/636/torch11b-10-prev.png" class="image-315883" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 24: Odhad pro číslici 9 pro střední hodnotu šumu od 0 do 1000.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vliv roztřesení obrázků na odhad sítě</h2>

<p>Mnohem větší vliv na schopnosti neuronové sítě rozeznat na validačních
obrázcích číslice bude mít operace roztřesení. Ostatně podívejte se sami na
následující obrázky a zjistíte, že u posledních dvou sekvencí již nemá
neuronová síť ale ani člověk prakticky žádnou šanci rozeznat, jaké číslice se
obrázku nacházely:</p>

<img src="https://i.iinfo.cz/images/475/torch11c-1.png" class="image-315884" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 25: Jittering je nastaven na hodnotu 1.</i></p>

<img src="https://i.iinfo.cz/images/475/torch11c-2.png" class="image-315885" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 26: Jittering je nastaven na hodnotu 2.</i></p>

<img src="https://i.iinfo.cz/images/475/torch11c-3.png" class="image-315886" alt="&#160;" height="391" width="309" />
<p><i>Obrázek 27: Jittering je nastaven na hodnotu 5.</i></p>

<img src="https://i.iinfo.cz/images/475/torch11c-4.png" class="image-315887" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 28: Jittering je nastaven na hodnotu 10.</i></p>

<img src="https://i.iinfo.cz/images/475/torch11c-5.png" class="image-315888" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 29: Jittering je nastaven na hodnotu 20.</i></p>

<p>To, že se síti rozpoznávání už tak dobře nedaří, můžeme vidět i
z&nbsp;průběhu validace:</p>

<p>Jittering je nastaven na hodnotu 1:</p>

<pre>
0       0       true    0.35910954151032
1       1       true    0.57856174459343
2       2       true    0.40019361990113
3       3       true    0.54086705757525
4       4       true    0.58778335183714
5       5       true    0.27008819125063
6       6       true    0.35776762022894
7       7       true    0.4531367614001
8       4       false   0.21041576508232
9       9       true    0.3519680014153
---------------------
Errors: 1
Error rate: 10%
</pre>

<p>Jittering je nastaven na hodnotu 2:</p>

<pre>
0       0       true    0.38051842884868
1       1       true    0.38103882055846
2       2       true    0.39405629490146
3       3       true    0.45315678727988
4       4       true    0.50494134273053
5       3       false   0.19587720231237
6       6       true    0.23127709141202
7       7       true    0.31614212052061
8       9       false   0.2558102855285
9       9       true    0.32458093384014
---------------------
Errors: 2
Error rate: 20%
</pre>

<p>Jittering je nastaven na hodnotu 5:</p>

<pre>
0       4       false   0.28540120686069
1       1       true    0.30647200639512
2       2       true    0.34205264219205
3       3       true    0.34558813657259
4       4       true    0.34545742784285
5       4       false   0.16762162756383
6       9       false   0.21334603720808
7       9       false   0.23076108525153
8       3       false   0.20003963876897
9       0       false   0.28069596444979
---------------------
Errors: 6
Error rate: 60%
</pre>

<p>Jittering je nastaven na hodnotu 10:</p>

<pre>
0       0       true    0.22012625858352
1       1       true    0.32947438362054
2       2       true    0.25733056743774
3       2       false   0.2330541164283
4       4       true    0.30746443359153
5       4       false   0.1976126151968
6       3       false   0.23027809292622
7       9       false   0.23223999329789
8       2       false   0.23371376521436
9       3       false   0.22685291894002
---------------------
Errors: 6
Error rate: 60%
</pre>

<p>Jittering je nastaven na hodnotu 20:</p>

<pre>
0       0       true    0.19842203869463
1       2       false   0.25433237722833
2       3       false   0.24291030056728
3       3       true    0.21615011335859
4       4       true    0.21841478740651
5       2       false   0.17700056607258
6       2       false   0.27402457656592
7       9       false   0.23169880374807
8       3       false   0.22503740085146
9       3       false   0.19410856562881
---------------------
Errors: 7
Error rate: 70%
</pre>

<p>V&nbsp;posledních třech validačních krocích je odhad víceméně náhodný a
navíc jsou pravděpodobnosti prakticky stejné.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Postupné zvyšování míry rozstřesení a odhad sítě vynesený do grafů</h2>

<p>Ještě více jsou patrné problémy konvoluční neuronové sítě při klasifikaci
číslic ve chvíli, kdy do grafu vyneseme odhad sítě pro rostoucí míru (úroveň)
rozstřesení. Krásně odlišené pruhy, které jsme viděli v&nbsp;předchozích
kapitolách, zde již nevidíme, pouze prakticky náhodný odhad sítě při vyšší míře
rozstřesení (to je ovšem pochopitelné):</p>

<a href="https://www.root.cz/obrazek/315889/"><img src="https://i.iinfo.cz/images/554/torch11d-1-prev.png" class="image-315889" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 30: Odhad pro číslici 0 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315890/"><img src="https://i.iinfo.cz/images/554/torch11d-2-prev.png" class="image-315890" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 31: Odhad pro číslici 1 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315891/"><img src="https://i.iinfo.cz/images/554/torch11d-3-prev.png" class="image-315891" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 32: Odhad pro číslici 2 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315892/"><img src="https://i.iinfo.cz/images/554/torch11d-4-prev.png" class="image-315892" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 33: Odhad pro číslici 3 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315893/"><img src="https://i.iinfo.cz/images/554/torch11d-5-prev.png" class="image-315893" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 34: Odhad pro číslici 4 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315894/"><img src="https://i.iinfo.cz/images/554/torch11d-6-prev.png" class="image-315894" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 35: Odhad pro číslici 5 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315895/"><img src="https://i.iinfo.cz/images/554/torch11d-7-prev.png" class="image-315895" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 36: Odhad pro číslici 6 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315896/"><img src="https://i.iinfo.cz/images/554/torch11d-8-prev.png" class="image-315896" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 37: Odhad pro číslici 7 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315897/"><img src="https://i.iinfo.cz/images/554/torch11d-9-prev.png" class="image-315897" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 38: Odhad pro číslici 8 pro míru rozstřesení od 0 do 20.</i></p>

<a href="https://www.root.cz/obrazek/315898/"><img src="https://i.iinfo.cz/images/554/torch11d-10-prev.png" class="image-315898" alt="&#160;" height="139" width="370" /></a>
<p><i>Obrázek 39: Odhad pro číslici 9 pro míru rozstřesení od 0 do 20.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračním příklady</h2>

<p>Všechny demonstrační příklady, které jsme si popsali v&nbsp;předchozích
kapitolách, najdete v&nbsp;GIT repositáři dostupném na adrese <a
href="https://github.com/tisnik/torch-examples.git">https://github.com/tisnik/torch-examples.git</a>.
Následují odkazy na zdrojové kódy jednotlivých příkladů:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>image_lib/image_renderer.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_renderer.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_renderer.lua</a></td></tr>
<tr><td>image_lib/image_filters.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_filters.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_filters.lua</a></td></tr>
<tr><td>image_lib/image_generator.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_generator.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_generator.lua</a></td></tr>
<tr><td>image_lib/image_writer.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_writer.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/image_lib/image_writer.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>nn/nn_constructor.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_constructor.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_constructor.lua</a></td></tr>
<tr><td>nn/nn_trainer.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_trainer.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_trainer.lua</a></td></tr>
<tr><td>nn/nn_validators.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_validators.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/nn/nn_validators.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>convolution_network_noisy_images.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/convolution_network_noisy_images.lua">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/convolution_network_noisy_images.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>run.sh</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/run.sh">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/run.sh</a></td></tr>
<tr><td>clean.sh</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/clean.sh">https://github.com/tisnik/torch-examples/blob/master/nn/convolution_network_project/clean.sh</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>THE MNIST DATABASE of handwritten digits<br />
<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>
</li>

<li>MNIST database (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MNIST_database">https://en.wikipedia.org/wiki/MNIST_database</a>
</li>

<li>MNIST For ML Beginners<br />
<a href="https://www.tensorflow.org/get_started/mnist/beginners">https://www.tensorflow.org/get_started/mnist/beginners</a>
</li>

<li>Stránka projektu Torch<br />
<a href="http://torch.ch/">http://torch.ch/</a>
</li>

<li>Torch: Serialization<br />
<a href="https://github.com/torch/torch7/blob/master/doc/serialization.md">https://github.com/torch/torch7/blob/master/doc/serialization.md</a>
</li>

<li>Torch: modul image<br />
<a href="https://github.com/torch/image/blob/master/README.md">https://github.com/torch/image/blob/master/README.md</a>
</li>

<li>Data pro neuronové sítě<br />
<a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a>
</li>

<li>LED Display Domain Data Set<br />
<a href="http://archive.ics.uci.edu/ml/datasets/LED+Display+Domain">http://archive.ics.uci.edu/ml/datasets/LED+Display+Domain</a>
</li>

<li>Torch na GitHubu (několik repositářů)<br />
<a href="https://github.com/torch">https://github.com/torch</a>
</li>

<li>Torch (machine learning), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Torch_%28machine_learning%29">https://en.wikipedia.org/wiki/Torch_%28machine_learning%29</a>
</li>

<li>Torch Package Reference Manual<br />
<a href="https://github.com/torch/torch7/blob/master/README.md">https://github.com/torch/torch7/blob/master/README.md</a>
</li>

<li>Torch Cheatsheet<br />
<a href="https://github.com/torch/torch7/wiki/Cheatsheet">https://github.com/torch/torch7/wiki/Cheatsheet</a>
</li>

<li>Neural network containres (Torch)<br />
<a href="https://github.com/torch/nn/blob/master/doc/containers.md">https://github.com/torch/nn/blob/master/doc/containers.md</a>
</li>

<li>Simple layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear">https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear</a>
</li>

<li>Transfer Function Layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok">https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok</a>
</li>

<li>Feedforward neural network<br />
<a href="https://en.wikipedia.org/wiki/Feedforward_neural_network">https://en.wikipedia.org/wiki/Feedforward_neural_network</a>
</li>

<li>Biologické algoritmy (4) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/</a>
</li>

<li>Biologické algoritmy (5) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/</a>
</li>

<li>Umělá neuronová síť (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5">https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5</a>
</li>

<li>Učení s učitelem (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/U%C4%8Den%C3%AD_s_u%C4%8Ditelem">https://cs.wikipedia.org/wiki/U%C4%8Den%C3%AD_s_u%C4%8Ditelem</a>
</li>

<li>Plotting with Torch7<br />
<a href="http://www.lighting-torch.com/2015/08/24/plotting-with-torch7/">http://www.lighting-torch.com/2015/08/24/plotting-with-torch7/</a>
</li>

<li>Plotting Package Manual with Gnuplot<br />
<a href="https://github.com/torch/gnuplot/blob/master/README.md">https://github.com/torch/gnuplot/blob/master/README.md</a>
</li>

<li>An Introduction to Tensors<br />
<a href="https://math.stackexchange.com/questions/10282/an-introduction-to-tensors">https://math.stackexchange.com/questions/10282/an-introduction-to-tensors</a>
</li>

<li>Gaussian filter<br />
<a href="https://en.wikipedia.org/wiki/Gaussian_filter">https://en.wikipedia.org/wiki/Gaussian_filter</a>
</li>

<li>Gaussian function<br />
<a href="https://en.wikipedia.org/wiki/Gaussian_function">https://en.wikipedia.org/wiki/Gaussian_function</a>
</li>

<li>Laplacian/Laplacian of Gaussian<br />
<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm">http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm</a>
</li>

<li>Odstranění šumu<br />
<a href="https://cs.wikipedia.org/wiki/Odstran%C4%9Bn%C3%AD_%C5%A1umu">https://cs.wikipedia.org/wiki/Odstran%C4%9Bn%C3%AD_%C5%A1umu</a>
</li>

<li>Binary image<br />
<a href="https://en.wikipedia.org/wiki/Binary_image">https://en.wikipedia.org/wiki/Binary_image</a>
</li>

<li>Erosion (morphology)<br />
<a href="https://en.wikipedia.org/wiki/Erosion_%28morphology%29">https://en.wikipedia.org/wiki/Erosion_%28morphology%29</a>
</li>

<li>Dilation (morphology)<br />
<a href="https://en.wikipedia.org/wiki/Dilation_%28morphology%29">https://en.wikipedia.org/wiki/Dilation_%28morphology%29</a>
</li>

<li>Mathematical morphology<br />
<a href="https://en.wikipedia.org/wiki/Mathematical_morphology">https://en.wikipedia.org/wiki/Mathematical_morphology</a>
</li>

<li>Cvičení 10 - Morfologické operace<br />
<a href="http://midas.uamt.feec.vutbr.cz/ZVS/Exercise10/content_cz.php">http://midas.uamt.feec.vutbr.cz/ZVS/Exercise10/content_cz.php</a>
</li>

<li>Differences between a matrix and a tensor<br />
<a href="https://math.stackexchange.com/questions/412423/differences-between-a-matrix-and-a-tensor">https://math.stackexchange.com/questions/412423/differences-between-a-matrix-and-a-tensor</a>
</li>

<li>Qualitatively, what is the difference between a matrix and a tensor?<br />
<a href="https://math.stackexchange.com/questions/1444412/qualitatively-what-is-the-difference-between-a-matrix-and-a-tensor?">https://math.stackexchange.com/questions/1444412/qualitatively-what-is-the-difference-between-a-matrix-and-a-tensor?</a>
</li>

<li>BLAS (Basic Linear Algebra Subprograms)<br />
<a href="http://www.netlib.org/blas/">http://www.netlib.org/blas/</a>
</li>

<li>Basic Linear Algebra Subprograms (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms</a>
</li>

<li>Comparison of deep learning software<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software">https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software</a>
</li>

<li>TensorFlow<br />
<a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a>
</li>

<li>Caffe2 (A New Lightweight, Modular, and Scalable Deep Learning Framework)<br />
<a href="https://caffe2.ai/">https://caffe2.ai/</a>
</li>

<li>PyTorch<br />
<a href="http://pytorch.org/">http://pytorch.org/</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>Lua Profiler (GitHub)<br />
<a href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>
</li>

<li>Lua Profiler (LuaForge)<br />
<a href="http://luaforge.net/projects/luaprofiler/">http://luaforge.net/projects/luaprofiler/</a>
</li>

<li>ctrace<br />
<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>LuaJIT 2.0 SSA IR<br />
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

