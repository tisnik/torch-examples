<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Framework Torch: klasifikace objektů na obrázcích z reálného světa</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Framework Torch: klasifikace objektů na obrázcích z reálného světa</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvanácté části seriálu o frameworku Torch se pokusíme vytvořit konvoluční neuronovou síť takovým způsobem, aby uspokojivě klasifikovala obrázky získané ze známé databáze CIFAR-10.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Framework Torch: klasifikace objektů na obrázcích z&nbsp;reálného světa</a></p>
<p><a href="#k02">2. Databáze CIFAR-10</a></p>
<p><a href="#k03">3. Nový projekt určený pro trénink a validaci konvoluční neuronové sítě</a></p>
<p><a href="#k04">4. Moduly umístěné v&nbsp;adresáři <strong>image_lib</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k041">4.1. Modul <strong>image_writer</strong></a></p>
<p><a href="#k05">5. Moduly umístěné v&nbsp;adresáři <strong>nn</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k051">5.1 Modul <strong>nn_constructor</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k052">5.2 Modul <strong>nn_trainer</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k053">5.3 Modul <strong>nn_validators</strong></a></p>
<p><a href="#k06">6. Moduly umístěné v&nbsp;adresáři <strong>utils</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k061">6.1. Modul <strong>cifar_downloader</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k062">6.2. Modul <strong>classification_classes</strong></a></p>
<p><a href="#k07">7. Hlavní modul celého projektu</a></p>
<p><a href="#k08">8. Průběh tréningu konvoluční neuronové sítě</a></p>
<p><a href="#k09">9. Validace neuronové sítě</a></p>
<p><a href="#k10">10. Rozbor výsledků a zlepšení odhadu sítě</a></p>
<p><a href="#k11">11. Repositář s&nbsp;demonstračním projektem</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Framework Torch: klasifikace objektů na obrázcích z&nbsp;reálného světa</h2>

<p>V&nbsp;dnešním článku o frameworku Torch se již počtvrté budeme zabývat
problematikou rozpoznávání a klasifikace (rastrových) obrázků, a to jak
s&nbsp;využitím běžných neuronových sítí, tak i sítí konvolučních. Navážeme na
<a
href="https://www.root.cz/clanky/framework-torch-konfigurace-konvolucnich-neuronovych-siti/">část
předchozí</a>, v&nbsp;níž jsme si ukázali ucelený projekt použitelný pro
rozpoznávání cifer (0-9), a to i v&nbsp;těch případech, kdy jsou obrázky
podrobeny nějaké operaci zhoršující čitelnost (zašumění, jittering atd.).</p>

<img src="https://i.iinfo.cz/images/396/torch11a-1.png" class="image-315860" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 1: Validační obrázky použité minule. Úroveň šumu (rozptyl) byl
nastaven na hodnotu 100.</i></p>

<p>Námi vytvořená konvoluční neuronová síť neměla s&nbsp;klasifikací takových
obrázků prakticky žádné větší problémy, a to ani ve chvíli, kdy byla úroveň
šumu již velmi vysoká popř.&nbsp;když se ve větší míře použil jittering
(roztřesení). Ostatně si můžete sami vyzkoušet provést například rozmazání
validačních obrázků či aplikovat další &bdquo;problematické&ldquo; operace.
Zkusme se tedy zaměřit na složitější úkol, konkrétně na klasifikaci obrázků
získaných z&nbsp;databáze CIFAR-10.</p>

<img src="https://i.iinfo.cz/images/475/torch11c-1.png" class="image-315884" alt="&#160;" height="391" width="310" />
<p><i>Obrázek 2: Testovací obrázky použité minule. Jittering (roztřesení) je
nastaven na hodnotu 1.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Databáze CIFAR-10</h2>

<p>Jménem <i>CIFAR-10</i> se označuje databáze obrázků určených mj.&nbsp;i
k&nbsp;testování (ne)kvality neuronových sítí, které mají tyto obrázky
klasifikovat. Obrázky jsou rozděleny do dvou skupin, přičemž první skupinu
tvoří 50&nbsp;000 trénovacích obrázků a druhou skupinu pak 10&nbsp;000 obrázků
validačních či testovacích. Každý obrázek v&nbsp;databázi CIFAR-10 je
reprezentován v&nbsp;prostoru RGB (tři barvové roviny) a má rozlišení
32&times;32 pixelů, což není mnoho, protože na každém obrázku se nachází více
či méně rozpoznatelný objekt patřící do jedné z&nbsp;těchto kategorií:</p>

<table>
<tr><th>#</th><th>Kategorie</th></tr>
<tr><td>1<td>airplane</td></tr>
<tr><td>2<td>automobile</td></tr>
<tr><td>3<td>bird</td></tr>
<tr><td>4<td>cat</td></tr>
<tr><td>5<td>deer</td></tr>
<tr><td>6<td>dog</td></tr>
<tr><td>7<td>frog</td></tr>
<tr><td>8<td>horse</td></tr>
<tr><td>9<td>ship</td></tr>
<tr><td>10<td>truck</td></tr>
</table>

<p>Poznámka: jména kategorií je asi zbytečné překládat, navíc jsou
v&nbsp;databázi uloženy <i>indexy</i> každé kategorie, takže má význam dodržet
původní (abecední) řazení anglických názvů.</p>

<img src="https://i.iinfo.cz/images/656/torch12-1.png" class="image-316905" alt="&#160;" width="569" height="659" />
<p><i>Obrázek 3: Několik trénovacích obrázků s&nbsp;kočkami (kategorie
<strong>cat</strong>). Obrázky mají skutečně velikost pouze 32&times;32 pixelů
&ndash; nejedná se o ikony.</i></p>

<p>Celá databáze je dostupná na adrese <a
href="http://www.cs.toronto.edu/~kriz/cifar.html">http://www.cs.toronto.edu/~kriz/cifar.html</a>,
my ovšem použijeme již připravené <a
href="https://www.root.cz/clanky/framework-torch-serializace-a-deserializace-tenzoru-prace-s-grafy#k01">serializované
tenzory</a> připravené přímo pro použití ve frameworku Torch. Takto připravená
databáze je dostupná na adrese <a
href="https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip">https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip</a>,
ovšem nemusíte si ji stahovat ručně &ndash; to za nás provede projekt, který si
v&nbsp;dalších kapitolách popíšeme.</p>

<img src="https://i.iinfo.cz/images/656/torch12-2.png" class="image-316906" alt="&#160;" width="569" height="737" />
<p><i>Obrázek 4: Několik trénovacích obrázků s&nbsp;kamiony (kategorie
<strong>truck</strong>).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nový projekt určený pro trénink a validaci konvoluční neuronové sítě</h2>

<p>První verze projektu pro klasifikaci obrázků z&nbsp;CIFAR-10 se vlastně
principiálně nebude příliš odlišovat od předchozích projektů. Ostatně ani
k&nbsp;tomu (alespoň prozatím) není důvod &ndash; máme sérii obrázků,
z&nbsp;nichž každý obsahuje objekt spadající do jedné z&nbsp;deseti kategorií,
takže základní požadavky jsou skutečně stejné (výsledky již budou horší, jak
uvidíme dále).</p>

<a href="https://www.root.cz/obrazek/316907/"><img src="https://i.iinfo.cz/images/656/torch12-3-prev.png" class="image-316907" alt="&#160;" width="289" height="270" /></a>
<p><i>Obrázek 5: Pro představu, jaký poměrně složitý úkol bude na naši
neuronovou síť čekat &ndash; zvětšený trénovací obrázek s&nbsp;kočkou.</i></p>

<p>Pro klasifikaci obrázků z&nbsp;databáze CIFAR-10 si vytvoříme nový projekt,
jehož některé části jsou odvozeny od projektu popsaného minule. Celý projekt je
rozdělen do několika (konkrétně do sedmi) modulů, přičemž jednotlivé moduly
jsou rozděleny do několika podadresářů. Celková struktura projektu vypadá
následovně:</p>

<pre>
├── cifar_data_classificator.lua
├── image_lib
│   └── image_writer.lua
├── nn
│   ├── nn_constructor.lua
│   ├── nn_trainer.lua
│   └── nn_validators.lua
└── utils
    ├── cifar_downloader.lua
    └── classification_classes.lua
</pre>

<p>Kromě toho projekt obsahuje i několik pomocných skriptů.</p>

<p>Poznámka: tento projekt se záměrně podobá notebooku, který naleznete na
adrese <a
href="https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb">https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb</a>,
ovšem konfigurace neuronové sítě je naschvál odlišná (je prakticky kompletně
převzata z&nbsp;předchozího příkladu), navíc prozatím (opět naschvál)
neimplementujeme ani žádný preprocesing obrázků.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Moduly umístěné v&nbsp;adresáři <strong>image_lib</strong></h2>

<p>V&nbsp;této kapitole je stručně popsán jediný modul umístěný do adresáře
<strong>image_lib</strong>. V&nbsp;minulé části tohoto seriálu byl popsán
projekt, v&nbsp;němž byly v&nbsp;tomto adresáři umístěny hned čtyři moduly, ty
ovšem sloužily pro přípravu trénovacích i validačních obrázků. My však již máme
obrázky připraveny (tj.&nbsp;získány z&nbsp;databáze CIFAR-10), takže se nám
celý modul značně zjednodušil.</p>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 Modul <strong>image_writer</strong></h3>

<p>Jedná se o pomocný modul, který využijeme ve chvíli, když budeme potřebovat
zjistit, jak vlastně vypadají trénovací obrázky nebo který obrázek síť špatně
určila. První funkce slouží pro export obrázku z&nbsp;trénovacích dat, přičemž
převod tenzoru do rastrového obrázku uloženého ve formátu PNG za nás udělá
samotný framework Torch:</p>

<pre>
function <strong>write_training_image</strong>(training_set, n)
    <i>-- kontrola, jestli obrazek s danym indexem "n" skutecne existuje</i>
    local size=training_set.data:size(1)
    if n &lt; 1 or n &gt; size then
        print("Training image " .. n .. " does not exist!")
        return
    end
&nbsp;
    <i>-- index popisky obrazku</i>
    local label_index = training_set.label[n]
&nbsp;
    <i>-- vlastni (textovy) popisek obrazku</i>
    local label = classification_classes[label_index]
&nbsp;
    <i>-- ulozeni obrazku</i>
    store_image(training_set, n, label)
end
&nbsp;
&nbsp;
function <strong>store_image</strong>(training_set, n, label)
    <i>-- konstrukce jmena souboru</i>
    local filename = string.format("training_image_%05d_%s.png", n, label)
&nbsp;
    <i>-- zapis dat ve formatu PNG</i>
    local img = training_set.data[n]
    image.save(filename, img)
end
</pre>

<p>Takto jednoduše je možné vyexportovat všechny trénovací obrázky obsahující
objekt jednoho typu (například letadlo):</p>

<pre>
function <strong>write_training_images_with_label</strong>(training_set, label)
    <i>-- celkovy pocet obrazku v trenovaci mnozine</i>
    local size=training_set.data:size(1)
&nbsp;
    <i>-- index tridy obrazku</i>
    local label_index = get_label_index(label)
&nbsp;
    <i>-- projit vsemi obrazky v sade</i>
    for i = 1, size do
        <i>-- filtrace obrazku</i>
        if training_set.label[i] == label_index then
            store_image(training_set, i, label)
        end
    end
end
</pre>

<p>Poznámka: právě funkce <strong>write_training_images_with_label</strong>
byla použita při tvorbě screenshotů 3 a 4.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Moduly umístěné v&nbsp;adresáři <strong>nn</strong></h2>

<p>V&nbsp;této kapitole je stručně popsána trojice modulů umístěná do adresáře
<strong>nn</strong>.</p>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Modul <strong>nn_constructor</strong></h3>

<p>Tento modul obsahuje především funkci
<strong>construct_neural_network</strong> určenou pro vytvoření konvoluční
neuronové sítě se specifikovanou konfigurací &ndash; rozlišením vstupních
obrázků, počtem rovin (atributů), počtem skrytých neuronů ve druhé polovině
sítě atd. S&nbsp;významem jednotlivých konfiguračních parametrů jsme se
seznámili v&nbsp;předchozích dvou článcích:</p>

<pre>
function <strong>calculate_size_after_convolution</strong>(input_size, middle_planes, convolution_kernel_size, pooling_size)
    local size = input_size
    for i=1,#middle_planes do
        <i>-- velikost po projiti konvolucni vrstvou</i>
        size = size - convolution_kernel_size + 1
        <i>-- velikost po projiti pooling vrstvou</i>
        size = size / pooling_size
    end
    return size
end
</pre>

<p>Jednou z&nbsp;významných změn je to, že počet rovin na vstupu již nebude
roven jedné, ale třem (monochromatické versus RGB obrázky). To se sice ve
zdrojovém kódu neprojeví, ovšem hodnota argumentu <strong>input_planes</strong>
se změní:</p>

<pre>
function <strong>construct_neural_network</strong>(width, height, input_planes, middle_planes,
                                  hidden_neurons, output_neurons,
                                  convolution_kernel_size, pooling_size, pooling_step)
    local network = nn.Sequential()
&nbsp;
    local size_x = calculate_size_after_convolution(width, middle_planes, convolution_kernel_size, pooling_size)
    local size_y = calculate_size_after_convolution(height, middle_planes, convolution_kernel_size, pooling_size)
&nbsp;
    print("Size x: " .. size_x)
    print("Size y: " .. size_y)
&nbsp;
    <i>-- prvni konvolucni vrstva ocekavajici na vstupu 3D tenzor</i>
    <i>-- o velikosti:</i>
    <i>-- INPUT_PLANES x vyska x sirka</i>
    <i>--</i>
    <i>-- vysledkem je 3D tenzor o velikosti:</i>
    <i>-- MIDDLE_PLANES_1 x (vyska - CONVOLUTION_KERNEL_SIZE + 1) x (sirka - CONVOLUTION_KERNEL_SIZE + 1) </i>
    network:add(nn.SpatialConvolution(input_planes, middle_planes[1], convolution_kernel_size, convolution_kernel_size))
&nbsp;
    <i>-- nyni mame mezivysledky MIDDLE_PLANES_1 x (vyska-5+1) x (sirka-5+1)</i>
&nbsp;
    <i>-- nelinearni funkce</i>
    network:add(nn.Tanh())
&nbsp;
    <i>-- hledani maxima v regionech o velikosti 2x2 pixely</i>
    <i>-- s krokem nastavenym na 2 pixely v horizontalnim i 2 pixely ve vertikalnim smeru</i>
    network:add(nn.SpatialMaxPooling(pooling_size, pooling_size, pooling_step, pooling_step))
&nbsp;
    <i>-- druha konvolucni vrstva ocekavajici na vstupu 3D tenzor</i>
    <i>-- o velikosti MIDDLE_PLANES_1 x vyska x sirka</i>
    network:add(nn.SpatialConvolution(middle_planes[1], middle_planes[2], convolution_kernel_size, convolution_kernel_size))
&nbsp;
    <i>-- nelinearni funkce</i>
    network:add(nn.Tanh())
&nbsp;
    <i>-- opetovne hledani maxima v regionech o velikosti 2x2 pixely</i>
    <i>-- s krokem nastavenym na 2 pixely v horizontalnim i 2 pixely ve vertikalnim smeru</i>
    network:add(nn.SpatialMaxPooling(pooling_size, pooling_size, pooling_step, pooling_step))
&nbsp;
    <i>-- zmena tvaru: z 3D tenzoru AxBxC na 1D tenzor s A*B*C elementy</i>
    network:add(nn.View(middle_planes[2]*size_x*size_y))
&nbsp;
    <i>-- bezne vrstvy, jak je jiz zname</i>
    network:add(nn.Linear(middle_planes[2]*size_x*size_y, hidden_neurons))
&nbsp;
    <i>-- pridana nelinearni funkce</i>
    network:add(nn.ReLU())
&nbsp;
    <i>-- bezne vrstvy, jak je jiz zname</i>
    network:add(nn.Linear(hidden_neurons, output_neurons))
&nbsp;
    return network
end
</pre>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Modul <strong>nn_trainer</strong></h3>

<p>V&nbsp;modulu <strong>nn_trainer</strong> nalezneme především funkci volanou
pro vlastní trénink sítě (<strong>train_neural_network</strong>), ale taktéž
funkci pojmenovanou <strong>prepare_training_data</strong>, která ze vstupní
databáze CIFAR-10 vytvoří tabulku s&nbsp;tenzory určenými pro trénink sítě.
Připomeňme si, že trénovací tenzory obsahují dvojice vstup:očekávaný-výstup,
přičemž vstupem jsou jednotlivé obrázky (převedené na tenzory) a výstupem pak
tenzor s&nbsp;váhou odhadu objektu, který síť na obrázku nalezla:</p>

<pre>
function <strong>train_neural_network</strong>(network, training_data, learning_rate, max_iteration)
    local criterion = nn.MSECriterion()
    local trainer = nn.StochasticGradient(network, criterion)
    trainer.learningRate = learning_rate
    trainer.maxIteration = max_iteration
    trainer:train(training_data)
end
&nbsp;
&nbsp;
function <strong>generate_expected_output</strong>(class)
    local result = torch.zeros(CLASSES)
    result[class] = 1
    return result
end
</pre>

<p>Funkce pro přípravu trénovacích dat vlastně &bdquo;pouze&ldquo; provádí
konverzi mezi vstupním tenzorem o rozměrech 10000&times;3&times;32&times;32
komponent na tabulku s&nbsp;dvojicemi tenzorů. Tuto problematiku je možné ve
skutečnosti vykonat mnohem kratším kódem &ndash; změnou &bdquo;operátoru&ldquo;
indexování &ndash; ale prozatím nemusíme zdrojové kódy příliš komplikovat.
V&nbsp;průběhu ladění neuronové sítě může být vhodné omezit maximální počet
trénovacích obrázků, což je zajištěno existencí parametru
<strong>max_size_of_training_set</strong>:</p>

<pre>
function <strong>prepare_training_data</strong>(training_set, max_size_of_training_set)
    <i>-- celkovy pocet obrazku v trenovaci mnozine</i>
    local input_training_set_size = training_set.data:size(1)
    local training_data_size = math.min(input_training_set_size, max_size_of_training_set)
&nbsp;
    <i>-- priprava tenzoru s trenovacimi daty</i>
    local training_data = {}
    function training_data:size() return training_data_size end
&nbsp;
    <i>-- projit vsemi obrazky v sade</i>
    for i = 1, training_data_size do
        <i>-- tenzor s obrazkem ve formatu RGB</i>
        local input = training_set.data[i]:double()
        local label_index = training_set.label[i]
        <i>-- tenzor s desetiprvkovym vektorem obsahujicim jen hodnoty 0 a 1</i>
        local output = generate_expected_output(label_index)
        training_data[i] = {input, output}
    end
&nbsp;
    return training_data
end
</pre>

<p>Povšimněte si, že se logika tohoto kódu od minula vlastně příliš nezměnila,
až na jednu maličkost &ndash; třída nalezených objektů je reprezentována číslem
od 1 do 10, zatímco minule jsme používali přímo cifry 0 až 9.</p>



<p><a name="k053"></a></p>
<h3 id="k053">5.3 Modul <strong>nn_validators</strong></h3>

<p>Tento modul obsahuje především funkci
<strong>validate_neural_network</strong> provádějící validaci natrénované
neuronové sítě a několik funkcí pomocných. Pro validaci používáme sadu obrázků
získaných opět z&nbsp;databáze CIFAR-10. U obrázků se vypisuje přímo jméno
objektu, který se zde nachází (<i>expected</i>) i jméno objektu odhadovaného
neuronovou sítí:</p>

<pre>
function <strong>find_largest_item</strong>(tensor)
    local index = -1
    local value = -math.huge
    for i = 0, 9 do
        if tensor[i+1] &gt; value then
            index = i
            value = tensor[i+1]
        end
    end
    return index+1, value
end
&nbsp;
&nbsp;
function <strong>plot_graph</strong>(filename, values)
    gnuplot.pngfigure(filename)
    gnuplot.imagesc(values, 'color')
    gnuplot.raw("set terminal pngcairo size 1280, 480")
    gnuplot.plotflush()
    gnuplot.close()
end
&nbsp;
&nbsp;
function <strong>validate_neural_network</strong>(network, validation_set)
    local errors = 0
    local count = 0
&nbsp;
    <i>-- celkovy pocet obrazku ve validacni mnozine</i>
    local validation_set_size = validation_set.data:size(1)
    print(validation_set_size)
&nbsp;
    for i = 1, validation_set_size do
        <i>-- tenzor s obrazkem ve formatu RGB</i>
        local input = validation_set.data[i]:double()
        local output = network:forward(input)
        local result, weight = find_largest_item(output)
        local expected = validation_set.label[i]
        if expected ~= result then
            errors = errors + 1
        end
        <i>-- muzeme vypsat primo tridu objektu, nejen jeho cislo</i>
        print(classification_classes[expected], classification_classes[result], expected==result, weight)
        count = count + 1
    end
    print("---------------------")
    print("Errors: " .. errors)
    print("Error rate: " .. 100.0*errors/count .. "%")
end
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Moduly umístěné v&nbsp;adresáři <strong>utils</strong></h2>

<p>V&nbsp;podadresáři <strong>utils</strong> nalezneme dva pomocné moduly
nazvané <strong>cifar_downloader</strong> a
<strong>classification_classes</strong>. Podrobnější popis těchto modulů je
uveden v&nbsp;navazujících podkapitolách.</p>



<p><a name="k061"></a></p>
<h3 id="k061">6.1 Modul <strong>cifar_downloader</strong></h3>

<p>Pro stažení a rozbalení testovacích i trénovacích dat nám poslouží
následující skript nazvaný jednoduše <strong>cifar_downloader</strong>, který
bude volán z&nbsp;hlavního modulu. Tento skript pracuje velmi jednoduše:
nejprve otestuje existenci archivu se všemi daty a pokud soubor s&nbsp;archivem
neexistuje, stáhne ho z&nbsp;adresy <a
href="https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip">https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip</a>
(pozor, jedná se o poměrně velký soubor o velikosti 55 MB!). Následně se tento
archiv rozbalí, ale opět pouze tehdy, pokud nejsou nalezeny již rozbalené
soubory (očekávají se dva soubory, jeden s&nbsp;testovacími daty, druhý
s&nbsp;daty trénovacími):</p>

<pre>
original_data_address = "https://s3.amazonaws.com/torch7/data/cifar10torchsmall.zip"
&nbsp;
function <strong>file_exists</strong>(filename)
    local fin = io.open(filename,"r")
    if fin then
        io.close(fin)
        return true
    else
        return false
    end
end
&nbsp;
&nbsp;
function <strong>download_file</strong>(address, filename)
    local command = "wget -v -O " .. filename .. " " .. address
    os.execute(command)
end
&nbsp;
&nbsp;
function <strong>unzip_file</strong>(filename)
    local command = "unzip " .. filename
    os.execute(command)
end
&nbsp;
&nbsp;
function <strong>setup</strong>(address, filename)
    if not file_exists(filename) then
        download_file(address, filename)
    end
    if not file_exists("cifar10-test.t7") or
       not file_exists("cifar10-train.t7") then
        unzip_file(filename)
    end
end
&nbsp;
&nbsp;
--setup(original_data_address, "cifar10torchsmall.zip")
</pre>

<p>Poznámka: poslední řádek je zakomentovaný schválně, protože stažení a
rozbalení dat bude prováděno z&nbsp;hlavního modulu celého projektu.</p>



<p><a name="k062"></a></p>
<h3 id="k062">6.2 Modul <strong>classification_classes</strong></h3>

<p>Tento modul nazvaný <strong>classification_classes</strong> je velmi
jednoduchý, protože obsahuje pouze jedinou tabulku se jmény tříd obrázků (tato
jména jsou použita při exportu obrázků ze vstupní množiny) a taktéž pomocnou
funkci, která na základě jména třídy vrátí celé číslo v&nbsp;rozsahu 1..10.
Právě toto číslo (neboli celočíselný index) je použito ve vstupní množině pro
klasifikaci obrázků:</p>

<pre>
classification_classes = {
    'airplane',
    'automobile',
    'bird',
    'cat',
    'deer',
    'dog',
    'frog',
    'horse',
    'ship',
    'truck'
}
&nbsp;
&nbsp;
function <strong>get_label_index</strong>(label)
    for i, lbl in ipairs(classification_classes) do
        if lbl == label then
            return i
        end
    end
    return nil
end
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Hlavní modul celého projektu</h2>

<p>První verze hlavního modulu celého projektu, v&nbsp;níž jsou obsaženy
všechny důležité konstanty, vypadá následovně:</p>

<pre>
require("nn")
require("image")
require("gnuplot")
&nbsp;
require("image_lib/image_writer")
&nbsp;
require("nn/nn_constructor")
require("nn/nn_trainer")
require("nn/nn_validators")
&nbsp;
require("utils/cifar_downloader")
require("utils/classification_classes")
&nbsp;
&nbsp;
<i>-- globalni nastaveni</i>
<strong>CLASSES = 10</strong>
&nbsp;
&nbsp;
<i>-- parametry obrazku</i>
WIDTH = 32
HEIGHT = 32
&nbsp;
&nbsp;
<i>-- parametry neuronove site</i>
<strong>INPUT_PLANES = 3</strong>
&nbsp;
MIDDLE_PLANES = {64, 64}
&nbsp;
HIDDEN_NEURONS = 100
OUTPUT_NEURONS = 10
&nbsp;
<i>-- parametry konvolucni vrstvy</i>
CONVOLUTION_KERNEL_SIZE = 5
&nbsp;
<i>-- parametry pooling vrstvy</i>
POOLING_SIZE = 2
POOLING_STEP = 2
&nbsp;
<i>-- parametry pro uceni neuronove site</i>
MAX_ITERATION = 20
LEARNING_RATE = 0.01
&nbsp;
<strong>MAX_SIZE_OF_TRAINING_SET = 1000</strong>
&nbsp;
&nbsp;
&nbsp;
network = construct_neural_network(WIDTH, HEIGHT, INPUT_PLANES, MIDDLE_PLANES,
                                   HIDDEN_NEURONS, OUTPUT_NEURONS,
                                   CONVOLUTION_KERNEL_SIZE, POOLING_SIZE, POOLING_STEP)
&nbsp;
print("Struktura neuronove site")
print(network)
&nbsp;
setup_cifar_dataset(original_data_address, zip_file_name)
&nbsp;
input_training_set = torch.load('cifar10-train.t7')
&nbsp;
print("Struktura vstupnich dat")
print(input_training_set.data:size())
&nbsp;
training_data = prepare_training_data(input_training_set, MAX_SIZE_OF_TRAINING_SET)
&nbsp;
train_neural_network(network, training_data, LEARNING_RATE, MAX_ITERATION)
&nbsp;
validation_set = torch.load('cifar10-test.t7')
&nbsp;
validate_neural_network(network, validation_set)
</pre>

<p>Od příkladu popsaného v&nbsp;předchozím článku se změnil především způsob
získání trénovacích a validačních obrázků, ovšem zapomenout nesmíme ani na
změněnou hodnotu <strong>INPUT_PLANES</strong>, který reflektuje fakt, že
obrázky již nejsou monochromatické, ale jsou reprezentovány v&nbsp;barvovém
prostoru RGB.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Průběh tréningu konvoluční neuronové sítě</h2>

<p>Podívejme se na průběh tréningu (učení) námi vytvořené konvoluční neuronové
sítě. Po spuštění hlavního modulu projektu skriptem <strong>run.sh</strong> se
nejprve provede konstrukce sítě určené pro klasifikaci tenzorů
3&times;32&times;32 komponent. Struktura celé sítě se následně vypíše na
konzoli:</p>

<pre>
Size x: 5
Size y: 5
Struktura neuronove site
nn.Sequential {
  [input -&gt; (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (5) -&gt; (6) -&gt; (7) -&gt; (8) -&gt; (9) -&gt; (10) -&gt; output]
  (1): nn.SpatialConvolution(3 -&gt; 64, 5x5)
  (2): nn.Tanh
  (3): nn.SpatialMaxPooling(2x2, 2,2)
  (4): nn.SpatialConvolution(64 -&gt; 64, 5x5)
  (5): nn.Tanh
  (6): nn.SpatialMaxPooling(2x2, 2,2)
  (7): nn.View(1600)
  (8): nn.Linear(1600 -&gt; 100)
  (9): nn.ReLU
  (10): nn.Linear(100 -&gt; 10)
}
</pre>

<p>Následně dojde k&nbsp;načtení trénovacích dat (deserializaci tenzoru) a
vypíše se jejich struktura. Povšimněte si, že k&nbsp;dispozici máme
&bdquo;jen&ldquo; 10&times;000 trénovacích obrázků, nikoli 50&times;000, jak je
tomu v&nbsp;originální databázi:</p>

<pre>
Struktura vstupnich dat
 10000
     3
    32
    32
[torch.LongStorage of size 4]
</pre>

<p>Následuje vlastní učení sítě:</p>

<pre>
# StochasticGradient: training
# current error = 0.087419532316487
# current error = 0.08250235596666
# current error = 0.080230850680852
# current error = 0.077974234283241
</pre>

<p>povšimněte si, že může dojít ke kolísání chyby okolo nějaké chybové hodnoty
(zde přibližně 0.009). To může značit fakt, že se síť při učení dostala do
lokálního minima, ovšem pokud použijeme větší počet iterací, mělo by se toto
úskalí překonat:</p>

<pre>
# current error = 0.010221119870583
# current error = 0.0088532006341434
# current error = 0.010162795768825
# current error = 0.0098526088304169
# current error = 0.01331067852011
# current error = 0.010431707186109
# current error = 0.0095516891939589
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Validace neuronové sítě</h2>

<p>Dalším krokem je pochopitelně validace neuronové sítě.</p>

<img src="https://i.iinfo.cz/images/656/torch12-4.png" class="image-316908" alt="&#160;" width="569" height="657" />
<p><i>Obrázek 6: Sada testovacích obrázků s&nbsp;kočkami (kategorie
<strong>cat</strong>).</i></p>

<p>Ukažme si jen několik posledních výsledků. V&nbsp;prvním sloupci je vypsána
skutečná klasifikace obrázku získaná z&nbsp;testovacích dat, ve druhém sloupci
pak objekt, který rozpoznala síť. Následuje příznak shody a také
&bdquo;jistota&ldquo;, s&nbsp;jakou síť obrázek klasifikovala. Ideálně by se
zde měla vyskytovat jednička či vyšší hodnota, naproti tomu odhady 0,5 a menší
jsou příliš nejisté:</p>

<pre>
truck       truck       true    0.52322672637698
airplane    dog         false   0.35518980035599
deer        deer        true    1.4037388636467
horse       horse       true    0.35070451362636
ship        ship        true    0.25252624795777
cat         dog         false   0.45795296167838
automobile  airplane    false   0.30874442469959
bird        dog         false   0.26461606217843
airplane    airplane    true    0.5877179917673
automobile  automobile  true    0.36849457038214
dog         cat         false   0.2006054691743
ship        ship        true    0.637623002454
deer        airplane    false   0.42689508867567
frog        cat         false   0.3862858463384
cat         bird        false   0.65612247517723
ship        bird        false   0.14112528584036
automobile  truck       false   0.68867536855129
cat         cat         true    0.63109539823786
ship        airplane    false   0.54685976158814
-------------------------------------------------
Errors: 584
Error rate: 58.4%
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozbor výsledků a zlepšení odhadu sítě</h2>

<p>Výsledky validace sítě, s&nbsp;nimiž jsme se seznámili v&nbsp;předchozí
kapitole, nemusí na první pohled vypadat příliš povzbudivě. Musíme si ale
uvědomit, že se neuronová síť přece jen &bdquo;něco&ldquo; naučila, protože
kdyby jen náhodně hádala, dosahovala by chyba 90% a nikoli jen 58%. Navíc jsou
některé obrázky v&nbsp;databázi skutečně jen nesnadno rozeznatelné (například
hned první obrázek), takže chyby 0% nedosáhneme (pěkným výsledkem může být
10%). Některé další možnosti vylepšení si popíšeme příště. Jedná se především o
tyto oblasti:</p>

<ol>

<li>Až na několik nepatrných úprav používáme neuronovou síť určenou pro
rozpoznávání mnohem jednodušších objektů (teoreticky stačilo rozpoznat pozadí
od popředí). Jednou z&nbsp;oblastí vylepšení bude přidání další vrstvy či
vrstev, a to buď do konvoluční části sítě, nebo do části s&nbsp;běžně
propojenými neurony.</li>

<li>Díky zvětšení kapacity sítě v&nbsp;předchozím bodu bude praktické pro
trénink použít celou množinu trénovacích obrázků a nikoli jen prvních 1000 (pro
každou třídu jsme vlastně měli k&nbsp;dispozici zhruba 100 obrázků, což není
mnoho).</li>

<li>Prozatím jsme také neprováděli žádný preprocesing obrázků, což u
rozpoznávání monochromatických číslic příliš nevadilo, ale u plnobarevných
obrázků to již může být užitečné.</li>

<li>Užitečný může být i převod obrázků do jiného barvového prostoru, například
HSV, HSL, YCbCr atd., neboť se tím může snížit velká závislost odhadu sítě na
barvě objektu.</li>

</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Repositář s&nbsp;demonstračním projektem</h2>

<p>Demonstrační projekt, který jsme si popsali v&nbsp;předchozích kapitolách,
najdete v&nbsp;GIT repositáři dostupném na adrese <a
href="https://github.com/tisnik/torch-examples.git">https://github.com/tisnik/torch-examples.git</a>.
Následují odkazy na zdrojové kódy jednotlivých souborů projektu:</p>

<table>
<tr><th>Soubor</th><th>Adresa</th></tr>
<tr><td>image_lib/image_writer.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/image_lib/image_writer.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/image_lib/image_writer.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>nn/nn_constructor.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_constructor.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_constructor.lua</a></td></tr>
<tr><td>nn/nn_trainer.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_trainer.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_trainer.lua</a></td></tr>
<tr><td>nn/nn_validators.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_validators.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/nn/nn_validators.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>utils/cifar_downloader.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/utils/cifar_downloader.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/utils/cifar_downloader.lua</a></td></tr>
<tr><td>utils/classification_classes.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/utils/classification_classes.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/utils/classification_classes.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>cifar_data_classificator.lua</td><td><a href="https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/cifar_data_classificator.lua">https://github.com/tisnik/torch-examples/blob/master/nn/cifar_data_classificator/cifar_data_classificator.lua</a></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>CIFAR-10 Dataset<br />
<a href="http://www.cs.toronto.edu/~kriz/cifar.html">http://www.cs.toronto.edu/~kriz/cifar.html</a>
</li>

<li>CIFAR-10, CIFAR-100 dataset introduction<br />
<a href="http://corochann.com/cifar-10-cifar-100-dataset-introduction-1258.html">http://corochann.com/cifar-10-cifar-100-dataset-introduction-1258.html</a>
</li>

<li>Deep Learning with Torch<br />
<a href="https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb">https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb</a>
</li>

<li>THE MNIST DATABASE of handwritten digits<br />
<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>
</li>

<li>MNIST database (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MNIST_database">https://en.wikipedia.org/wiki/MNIST_database</a>
</li>

<li>MNIST For ML Beginners<br />
<a href="https://www.tensorflow.org/get_started/mnist/beginners">https://www.tensorflow.org/get_started/mnist/beginners</a>
</li>

<li>Stránka projektu Torch<br />
<a href="http://torch.ch/">http://torch.ch/</a>
</li>

<li>Torch: Serialization<br />
<a href="https://github.com/torch/torch7/blob/master/doc/serialization.md">https://github.com/torch/torch7/blob/master/doc/serialization.md</a>
</li>

<li>Torch: modul image<br />
<a href="https://github.com/torch/image/blob/master/README.md">https://github.com/torch/image/blob/master/README.md</a>
</li>

<li>Data pro neuronové sítě<br />
<a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a>
</li>

<li>LED Display Domain Data Set<br />
<a href="http://archive.ics.uci.edu/ml/datasets/LED+Display+Domain">http://archive.ics.uci.edu/ml/datasets/LED+Display+Domain</a>
</li>

<li>Torch na GitHubu (několik repositářů)<br />
<a href="https://github.com/torch">https://github.com/torch</a>
</li>

<li>Torch (machine learning), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Torch_%28machine_learning%29">https://en.wikipedia.org/wiki/Torch_%28machine_learning%29</a>
</li>

<li>Torch Package Reference Manual<br />
<a href="https://github.com/torch/torch7/blob/master/README.md">https://github.com/torch/torch7/blob/master/README.md</a>
</li>

<li>Torch Cheatsheet<br />
<a href="https://github.com/torch/torch7/wiki/Cheatsheet">https://github.com/torch/torch7/wiki/Cheatsheet</a>
</li>

<li>Neural network containres (Torch)<br />
<a href="https://github.com/torch/nn/blob/master/doc/containers.md">https://github.com/torch/nn/blob/master/doc/containers.md</a>
</li>

<li>Simple layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear">https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear</a>
</li>

<li>Transfer Function Layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok">https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok</a>
</li>

<li>Feedforward neural network<br />
<a href="https://en.wikipedia.org/wiki/Feedforward_neural_network">https://en.wikipedia.org/wiki/Feedforward_neural_network</a>
</li>

<li>Biologické algoritmy (4) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/</a>
</li>

<li>Biologické algoritmy (5) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/</a>
</li>

<li>Umělá neuronová síť (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5">https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5</a>
</li>

<li>Učení s učitelem (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/U%C4%8Den%C3%AD_s_u%C4%8Ditelem">https://cs.wikipedia.org/wiki/U%C4%8Den%C3%AD_s_u%C4%8Ditelem</a>
</li>

<li>Plotting with Torch7<br />
<a href="http://www.lighting-torch.com/2015/08/24/plotting-with-torch7/">http://www.lighting-torch.com/2015/08/24/plotting-with-torch7/</a>
</li>

<li>Plotting Package Manual with Gnuplot<br />
<a href="https://github.com/torch/gnuplot/blob/master/README.md">https://github.com/torch/gnuplot/blob/master/README.md</a>
</li>

<li>An Introduction to Tensors<br />
<a href="https://math.stackexchange.com/questions/10282/an-introduction-to-tensors">https://math.stackexchange.com/questions/10282/an-introduction-to-tensors</a>
</li>

<li>Gaussian filter<br />
<a href="https://en.wikipedia.org/wiki/Gaussian_filter">https://en.wikipedia.org/wiki/Gaussian_filter</a>
</li>

<li>Gaussian function<br />
<a href="https://en.wikipedia.org/wiki/Gaussian_function">https://en.wikipedia.org/wiki/Gaussian_function</a>
</li>

<li>Laplacian/Laplacian of Gaussian<br />
<a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm">http://homepages.inf.ed.ac.uk/rbf/HIPR2/log.htm</a>
</li>

<li>Odstranění šumu<br />
<a href="https://cs.wikipedia.org/wiki/Odstran%C4%9Bn%C3%AD_%C5%A1umu">https://cs.wikipedia.org/wiki/Odstran%C4%9Bn%C3%AD_%C5%A1umu</a>
</li>

<li>Binary image<br />
<a href="https://en.wikipedia.org/wiki/Binary_image">https://en.wikipedia.org/wiki/Binary_image</a>
</li>

<li>Erosion (morphology)<br />
<a href="https://en.wikipedia.org/wiki/Erosion_%28morphology%29">https://en.wikipedia.org/wiki/Erosion_%28morphology%29</a>
</li>

<li>Dilation (morphology)<br />
<a href="https://en.wikipedia.org/wiki/Dilation_%28morphology%29">https://en.wikipedia.org/wiki/Dilation_%28morphology%29</a>
</li>

<li>Mathematical morphology<br />
<a href="https://en.wikipedia.org/wiki/Mathematical_morphology">https://en.wikipedia.org/wiki/Mathematical_morphology</a>
</li>

<li>Cvičení 10 - Morfologické operace<br />
<a href="http://midas.uamt.feec.vutbr.cz/ZVS/Exercise10/content_cz.php">http://midas.uamt.feec.vutbr.cz/ZVS/Exercise10/content_cz.php</a>
</li>

<li>Differences between a matrix and a tensor<br />
<a href="https://math.stackexchange.com/questions/412423/differences-between-a-matrix-and-a-tensor">https://math.stackexchange.com/questions/412423/differences-between-a-matrix-and-a-tensor</a>
</li>

<li>Qualitatively, what is the difference between a matrix and a tensor?<br />
<a href="https://math.stackexchange.com/questions/1444412/qualitatively-what-is-the-difference-between-a-matrix-and-a-tensor?">https://math.stackexchange.com/questions/1444412/qualitatively-what-is-the-difference-between-a-matrix-and-a-tensor?</a>
</li>

<li>BLAS (Basic Linear Algebra Subprograms)<br />
<a href="http://www.netlib.org/blas/">http://www.netlib.org/blas/</a>
</li>

<li>Basic Linear Algebra Subprograms (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms</a>
</li>

<li>Comparison of deep learning software<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software">https://en.wikipedia.org/wiki/Comparison_of_deep_learning_software</a>
</li>

<li>TensorFlow<br />
<a href="https://www.tensorflow.org/">https://www.tensorflow.org/</a>
</li>

<li>Caffe2 (A New Lightweight, Modular, and Scalable Deep Learning Framework)<br />
<a href="https://caffe2.ai/">https://caffe2.ai/</a>
</li>

<li>PyTorch<br />
<a href="http://pytorch.org/">http://pytorch.org/</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>Lua Profiler (GitHub)<br />
<a href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>
</li>

<li>Lua Profiler (LuaForge)<br />
<a href="http://luaforge.net/projects/luaprofiler/">http://luaforge.net/projects/luaprofiler/</a>
</li>

<li>ctrace<br />
<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>LuaJIT 2.0 SSA IR<br />
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

